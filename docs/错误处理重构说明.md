# 错误处理系统重构说明

## 概述

本次重构采用现代的 Spring Boot 最佳实践，系统性地改进了错误处理机制，解决了无限递归问题，并使错误响应格式符合 API 文档规范。

## 主要变更

### 1. 删除过时的组件

#### 删除 `EarlyMethodNotAllowedFilter`
- **原因**：这是一个自定义的早期过滤器，试图在 Spring Security 之前拦截 405 错误
- **问题**：
  - 需要手动维护端点和方法的映射表，容易遗漏
  - 与 Spring MVC 的内置机制重复
  - 增加了系统复杂度
- **替代方案**：使用 `@ControllerAdvice` 中的 `@ExceptionHandler(HttpRequestMethodNotSupportedException.class)` 统一处理

#### 删除 `CustomErrorController`
- **原因**：实现了 Spring Boot 的 `ErrorController` 接口来处理 `/error` 端点
- **问题**：
  - 容易导致无限重定向循环
  - 循环检测逻辑不够健壮
  - 与现代的 `@ControllerAdvice` 方式冲突
- **替代方案**：使用 `@ControllerAdvice` 全局异常处理器，在异常到达 `/error` 之前就捕获处理

### 2. 新增现代化组件

#### `ErrorResponse` - 统一的错误响应 DTO
符合 API 文档 2.5 节定义的失败响应格式：

```json
{
  "timestamp": "2025-11-12T08:00:00Z",
  "status": 401,
  "error": "Unauthorized",
  "message": "Not authenticated",
  "errors": {
    "field": "error message"
  },
  "path": "/api/v1/some/path",
  "traceId": "a1b2c3d4"
}
```

**字段说明**：
- `timestamp`: ISO8601 格式的时间戳
- `status`: HTTP 状态码
- `error`: 错误类型（如 "Unauthorized", "Bad Request"）
- `message`: 用户友好的错误描述
- `errors`: 字段级错误信息（可选，用于表单验证）
- `path`: 请求路径（可选，用于调试）
- `traceId`: 追踪 ID（可选，用于日志关联）

#### `GlobalExceptionHandler` - 全局异常处理器
使用 `@ControllerAdvice` 注解，统一处理所有异常：

**处理的异常类型**：
1. **验证异常**
   - `MethodArgumentNotValidException` - `@Valid` 触发
   - `ConstraintViolationException` - `@Validated` 触发
   
2. **HTTP 相关异常**
   - `HttpRequestMethodNotSupportedException` - 405 Method Not Allowed
   - `HttpMediaTypeNotSupportedException` - 415 Unsupported Media Type
   - `HttpMessageNotReadableException` - 400 Bad Request (JSON 格式错误)
   - `MissingServletRequestParameterException` - 400 Bad Request (缺少参数)
   - `MethodArgumentTypeMismatchException` - 400 Bad Request (参数类型错误)
   
3. **路由异常**
   - `NoHandlerFoundException` - 404 Not Found
   - `NoResourceFoundException` - 404 Not Found
   
4. **安全异常**
   - `AuthenticationException` - 401 Unauthorized
   - `AccessDeniedException` - 403 Forbidden
   
5. **业务异常**
   - `ResponseStatusException` - 自定义状态码异常
   
6. **通用异常**
   - `Exception` - 500 Internal Server Error（兜底处理）

**特性**：
- 自动生成 8 位追踪 ID，便于日志关联
- 开发环境和生产环境的差异化处理
- 统一的日志记录
- 符合 API 文档的响应格式

### 3. 配置优化

更新 `application.properties`：

```properties
# 错误处理配置
# 禁用默认的白标签错误页面，使用自定义的 GlobalExceptionHandler
server.error.whitelabel.enabled=false
# 当没有找到处理器时抛出异常，而不是发送 404 响应
spring.mvc.throw-exception-if-no-handler-found=true
# 禁用静态资源映射（如果启用，404 会被静态资源处理器拦截）
spring.web.resources.add-mappings=false
# 在错误响应中包含异常信息（仅开发环境）
server.error.include-exception=false
server.error.include-message=always
server.error.include-stacktrace=never
server.error.include-binding-errors=always
```

**配置说明**：
- `server.error.whitelabel.enabled=false`: 禁用 Spring Boot 默认的白标签错误页面
- `spring.mvc.throw-exception-if-no-handler-found=true`: 404 时抛出异常而不是静默处理
- `spring.web.resources.add-mappings=false`: 禁用静态资源映射，确保 404 被正确处理
- `server.error.include-*`: 控制错误响应中包含的信息

## 解决的问题

### 1. 无限递归问题
**原问题**：POST `/api/v1/admin/users` 导致无限递归，直至内存溢出

**根本原因**：
1. 请求出错时，Spring 尝试转发到 `/error`
2. `CustomErrorController` 处理 `/error`，但可能再次触发错误
3. 循环检测逻辑不够强，导致无限循环

**解决方案**：
- 删除 `CustomErrorController`
- 使用 `@ControllerAdvice` 在异常到达 `/error` 之前就捕获处理
- 配置 `spring.web.resources.add-mappings=false` 防止静态资源处理器干扰

### 2. 405 错误处理不一致
**原问题**：`EarlyMethodNotAllowedFilter` 需要手动维护端点映射表

**解决方案**：
- 删除 `EarlyMethodNotAllowedFilter`
- Spring MVC 自动检测方法不匹配并抛出 `HttpRequestMethodNotSupportedException`
- `GlobalExceptionHandler` 统一处理，自动列出支持的方法

### 3. 错误响应格式不统一
**原问题**：不同的错误可能返回不同的响应格式

**解决方案**：
- 定义统一的 `ErrorResponse` DTO
- 所有异常处理器都返回相同的格式
- 符合 API 文档 2.5 节的规范

## 测试

运行测试脚本验证错误处理：

```bash
./scripts/fish/test_error_handling.fish
```

测试覆盖：
- ✅ 404 Not Found
- ✅ 405 Method Not Allowed
- ✅ 400 Bad Request (无效 JSON)
- ✅ 400 Validation Error (字段验证失败)
- ✅ 401 Unauthorized
- ✅ 403 Forbidden
- ✅ 无限递归问题修复验证

## 优势

### 1. 现代化
- 使用 Spring Boot 推荐的 `@ControllerAdvice` 方式
- 符合业界最佳实践
- 代码更简洁、可维护性更好

### 2. 可扩展
- 添加新的异常处理器只需在 `GlobalExceptionHandler` 中添加方法
- 不需要修改配置或过滤器链

### 3. 符合规范
- 完全符合 API 文档定义的错误响应格式
- 统一的追踪 ID 便于问题排查

### 4. 健壮性
- 不会出现无限递归
- 所有异常都有兜底处理
- 开发和生产环境差异化处理

## 后续优化建议

### 1. 错误码分层
API 文档 2.6 节定义了错误码分层（如 `AUTH.INVALID_TOKEN`），可以考虑：
- 定义自定义异常类（如 `AuthException`, `CourseException`）
- 在 `ErrorResponse` 中添加 `code` 字段
- 在异常处理器中映射到具体的错误码

### 2. 国际化
- 使用 Spring 的 `MessageSource` 支持多语言错误消息
- 根据 `Accept-Language` 头返回对应语言的错误信息

### 3. 监控和告警
- 集成 APM 工具（如 Prometheus, Grafana）
- 对 500 错误进行告警
- 统计各类错误的频率

## 迁移指南

如果有其他代码依赖旧的错误处理机制：

1. **删除对 `CustomErrorController` 的引用**
2. **删除对 `EarlyMethodNotAllowedFilter` 的引用**
3. **确保异常使用标准的 Spring 异常**：
   - 业务异常使用 `ResponseStatusException`
   - 验证使用 `@Valid` 和 `@Validated`
4. **测试所有错误场景**，确保返回正确的错误响应

## 总结

本次重构采用现代的 Spring Boot 最佳实践，系统性地解决了错误处理中的问题：
- ✅ 删除了过时的 `EarlyMethodNotAllowedFilter` 和 `CustomErrorController`
- ✅ 实现了统一的 `GlobalExceptionHandler`
- ✅ 定义了符合 API 文档的 `ErrorResponse` 格式
- ✅ 解决了无限递归问题
- ✅ 提供了完整的测试脚本

系统现在拥有更健壮、更易维护的错误处理机制。

